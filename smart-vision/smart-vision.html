// === SMART VISION STREAMING ===
// ðŸŽ§ Ð—Ð°Ð¿ÑƒÑÐº Ð¸ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¼Ð¸ÐºÑ€Ð¾Ñ„Ð¾Ð½Ð¾Ð¼

let mediaRecorder;
let isRecording = false;
let audioChunks = [];
let accumulatedText = "";

// Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚ Ð´Ð»Ñ Ð²Ñ‹Ð²Ð¾Ð´Ð° Ñ‚ÐµÐºÑÑ‚Ð°
const output = document.getElementById("output");
const micBtn = document.getElementById("micBtn");

// ÐŸÐ»Ð°Ð²Ð½Ð°Ñ Ð¿ÐµÑ‡Ð°Ñ‚ÑŒ Ñ‚ÐµÐºÑÑ‚Ð°
function appendTextGradually(newText) {
  let i = 0;
  const speed = 25; // ÑÐºÐ¾Ñ€Ð¾ÑÑ‚ÑŒ Ð¿Ð¾ÑÐ²Ð»ÐµÐ½Ð¸Ñ ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²
  const interval = setInterval(() => {
    if (i < newText.length) {
      output.textContent += newText[i];
      i++;
    } else {
      clearInterval(interval);
    }
  }, speed);
}

// === ðŸŽ™ Ð—Ð°Ð¿ÑƒÑÐº Ð¼Ð¸ÐºÑ€Ð¾Ñ„Ð¾Ð½Ð° ===
async function startMic() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

    const mimeType = MediaRecorder.isTypeSupported("audio/ogg;codecs=opus")
      ? "audio/ogg;codecs=opus"
      : "audio/webm;codecs=opus";

    mediaRecorder = new MediaRecorder(stream, { mimeType });

    console.log("ðŸŽ™ Recorder format:", mimeType);

    mediaRecorder.ondataavailable = async (e) => {
      if (e.data.size > 0) {
        const blob = e.data;
        await sendAudioChunk(blob);
      }
    };

    mediaRecorder.start(2000); // ÐºÐ°Ð¶Ð´Ñ‹Ðµ 2 ÑÐµÐºÑƒÐ½Ð´Ñ‹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼
    isRecording = true;
    micBtn.classList.add("recording");
    output.textContent = "Ð¡Ð»ÑƒÑˆÐ°ÑŽ... ðŸŽ§";

    console.log("ðŸŽ¤ Recording started");
  } catch (err) {
    console.error("ÐžÑˆÐ¸Ð±ÐºÐ° Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð° Ðº Ð¼Ð¸ÐºÑ€Ð¾Ñ„Ð¾Ð½Ñƒ:", err);
    alert("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ð¼Ð¸ÐºÑ€Ð¾Ñ„Ð¾Ð½Ñƒ");
  }
}

// === ðŸ›‘ ÐžÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° ===
function stopMic() {
  if (mediaRecorder && isRecording) {
    mediaRecorder.stop();
    isRecording = false;
    micBtn.classList.remove("recording");
    output.textContent += "\n\nâœ… Ð—Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¾.";
    console.log("ðŸŽ¤ Recording stopped");
  }
}

// === ðŸ“¡ ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ñ‡Ð°Ð½ÐºÐ° ===
async function sendAudioChunk(blob) {
  try {
    const formData = new FormData();
    formData.append("file", blob, "audio.ogg");

    const res = await fetch("/.netlify/functions/transcribe", {
      method: "POST",
      body: formData,
    });

    if (!res.ok) {
      console.error("Transcribe error:", res.status);
      return;
    }

    const data = await res.json();
    if (data.text) {
      appendTextGradually(data.text + " ");
      accumulatedText += data.text + " ";
    }
  } catch (err) {
    console.error("Transcribe fetch error:", err);
  }
}

// === ðŸŽ› Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ ÐºÐ½Ð¾Ð¿ÐºÐ¾Ð¹ ===
micBtn.addEventListener("click", () => {
  if (!isRecording) {
    output.textContent = "";
    startMic();
  } else {
    stopMic();
  }
});
